import pandas as pd
import spacy
from spacy.matcher import Matcher
import rdflib
from rdflib import Graph, RDF, URIRef, Namespace

nlp = spacy.load("fr_core_news_sm")

EX = Namespace("http://example.org/")



# Fonction pour créer des URI uniques
def create_uri(entity):
    return URIRef(EX + entity.replace(" ", "_"))

def extract_entities_relations(text):

    doc = nlp(text)
    entities = [ent.text for ent in doc.ents]
    
    relations = []
    matcher = Matcher(nlp.vocab)

    # Définir la structure de la relation
    pattern = [{'DEP':'ROOT'}, 
               {'DEP':'prep','OP':"?"},
               {'DEP':'agent','OP':"?"},  
               {'POS':'ADJ','OP':"?"}] 

    matcher.add("matching_1", [pattern]) 
    matches = matcher(doc)
    k = len(matches) - 1
    span = doc[matches[k][1]:matches[k][2]] 
    relation = span.text
    
    return entities, relation

def graphe():
    g = Graph()
    g.bind("ex", EX)
    df = pd.read_csv("/Users/danielb/Desktop/Projet HNAPP/hnapp/Developpement/graphe_de_connaissances/phrases_de_test.csv", encoding="ISO-8859-1")

    for _, row in df.iterrows():
        entities, relation = extract_entities_relations(row['phrase'])

        for entity in entities:
            g.add((create_uri(entity), RDF.type, EX.Entity))

        for i, entity1 in enumerate(entities):
            for j, entity2 in enumerate(entities):
                if i != j:
                    g.add((create_uri(entity1), URIRef(EX + relation.replace(" ", "_")), create_uri(entity2)))


    # Sauvegarder le graphe en RDF/XML
    g.serialize("/Users/danielb/Desktop/Projet HNAPP/hnapp/Developpement/graphe_de_connaissances\output1.rdf", format="xml")
   
    return g
graphe()

#Exploitation des données RDF : 
#Parcours en largeur pour obtenir les données connexes à une notion particulière.

def dfs(r):
    
    g = graphe()
    neighboors = dict() 
    for s, p, o in g:
        neighboors[s] = []
    for s, p, o in g:
        neighboors[s].append(o)
        
   
    stack = [(-1,r)]
    parent = dict()
    while stack:
        u,v = stack.pop()
        if v not in parent:
            parent[v] = u
            for w in reversed(neighboors[v]):
                stack.append((v,w))
        return parent
    
    #Convertir en un sous-graphe RDF : 
    graphConstruct = Graphe()
    for v in parent:
        graphConstruct.add(v,RDF.type,u)
        
    with open("graphe.ttl", "wb") as f:
        f.write(graphConstruct.serialize(format="turtle"))
    return graphConstruct
    
    

#dfs(URIRef('http://example.org/Athènes')) 

